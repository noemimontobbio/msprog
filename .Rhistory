results <- results[-subj_index, ]
rownames(results) <- NULL # reset column names
}
improvement <- sum(results[results[[subj_col]] == subjid, "event_type"] == "impr")
progression <- sum(results[results[[subj_col]] == subjid, "event_type"] %in% c("prog", "RAW", "PIRA"))
undefined_prog <- sum(results[results[[subj_col]] == subjid, "event_type"] == "prog")
RAW <- sum(results[results[[subj_col]] == subjid, "event_type"] == "RAW")
PIRA <- sum(results[results[[subj_col]] == subjid, "event_type"] == "PIRA")
summary[as.character(subjid), c('improvement', 'progression', 'RAW', 'PIRA', 'undefined_prog'
)] <- c(improvement, progression, RAW, PIRA, undefined_prog)
summary[as.character(subjid), 'event_sequence'] <- paste(event_type, collapse = ", ")
if (startsWith(event, "firstprog")) {
summary <- summary[, !colnames(summary) %in% "improvement"]
}
if (verbose == 2) {
message("Event sequence: ", ifelse(length(event_type) > 0,
paste(event_type, collapse = ", "), "-"), sep = "")
}
data_id
data_id = data_id[order(-data_id[[value_col]]), ]
data_id
# If more than one visit occur on the same day, only keep last
ucounts <- table(data_id[, date_col])
if (any(ucounts > 1)) {
data_id <- data_id %>% group_by_at(vars(date_col)) %>% slice(n())
}
# Sort visits in chronological order
order_tmp <- order(data_id[[date_col]])
if (any(order_tmp != rownames(data_id))) {
data_id <- data_id[order_tmp, ]
}
nvisits <- nrow(data_id)
first_visit <- min(data_id[[date_col]])
relapse_id <- relapse[relapse[[rsubj_col]] == subjid, ]
relapse_id <- relapse_id[relapse_id[[rdate_col]] >= first_visit - as.difftime(rel_infl, units = "days"), ]
relapse_dates <- relapse_id[[rdate_col]]
nrel <- length(relapse_dates)
if (verbose == 2) {
message("\nSubject #", subjid, ": ", nvisits, " visit", ifelse(nvisits == 1, "", "s"),
", ", nrel, " relapse", ifelse(nrel == 1, "", "s"))
if (any(ucounts > 1)) {
message("Found multiple visits in the same day: only keeping last.")
}
if (any(order_tmp != rownames(data_id))) {
message("Visits not listed in chronological order: sorting them.")
}
}
all_dates <- unique(c(data_id[[date_col]], relapse_dates))
sorted_ind <- order(all_dates)
all_dates <- all_dates[sorted_ind]
is_rel <- all_dates %in% relapse_dates
date_dict <- setNames(1:length(all_dates), sorted_ind)
if (length(relapse_dates) > 0) {
relapse_df <- data.frame(split(rep(relapse_dates, each=nrow(data_id)),
rep(1:length(relapse_dates), each=nrow(data_id))))
relapse_df$visit <- data_id[,][[date_col]]
dist = (relapse_df %>% mutate(across(1:length(relapse_dates),
~ as.numeric(.x - visit))))[1:length(relapse_dates)]
distm <- - dist
distp <- dist
distm[distm<0] = Inf
distp[distp<0] = Inf
data_id$closest_rel_minus <- if (all(is.na(distm))) Inf else apply(distm, 1, min, na.rm = TRUE)
data_id$closest_rel_plus <- if (all(is.na(distp))) Inf else apply(distp, 1, min, na.rm = TRUE)
} else {
data_id$closest_rel_minus <- Inf
data_id$closest_rel_plus <- Inf
}
event_type <- ""
event_index <- NULL
bldate <- edate <- blvalue <- evalue <- time2event <- sustd <- sustl <- vector()
conf <- pira_conf <- list()
for (m in conf_months) {
conf[[as.character(m)]] <- vector()
if (m!=conf_months[1]) {pira_conf[[as.character(m)]] <- vector()}
}
bl_idx <- 1
search_idx <- 2
proceed <- 1
phase <- 0
while (proceed) {
# Set baseline (skip if within relapse influence)
while (proceed && data_id[bl_idx, 'closest_rel_minus'] <= rel_infl) {
if (verbose == 2) {
message("Baseline (visit no.", bl_idx,
") is within relapse influence: moved to visit no.", bl_idx + 1)
}
bl_idx <- bl_idx + 1
search_idx <- search_idx + 1
if (bl_idx > nvisits - 1) {
proceed <- 0
if (verbose == 2) {
message("Not enough visits left: end process")
}
}
}
if (bl_idx > nvisits - 1) {
break
}
bl <- data_id[bl_idx, ]
# Event detection
change_idx <- match(TRUE, data_id[search_idx:nvisits, value_col] != as.numeric(bl[value_col]))
if (!is.na(change_idx)) {
change_idx <- search_idx + change_idx - 1
}
if (is.na(change_idx) | change_idx>nvisits) {
proceed <- 0
if (verbose == 2) {
message("No ", toupper(outcome), " change in any subsequent visit: end process")
}
} else {
if (change_idx==nvisits) {
conf_idx=list()
} else {
conf_idx <- lapply(conf_window, function(t) {
match_idx <- NULL
for (x in (change_idx + 1):nvisits) {
if (difftime(data_id[x,][[date_col]], data_id[change_idx,][[date_col]]) >= t[1] &&
difftime(data_id[x,][[date_col]], data_id[change_idx,][[date_col]]) <= t[2] &&
data_id[x, 'closest_rel_minus'] > rel_infl) {
match_idx <- x
break
}
}
match_idx
})
conf_t <- list()
for (m in 1:length(conf_months)) {if (!is.null(conf_idx[[m]])) {conf_t = c(conf_t, conf_months[m])}}
conf_idx <- Filter(Negate(is.null), conf_idx)
}
if (verbose == 2) {
message(toupper(outcome), " change at visit no.", change_idx, " (", data_id[change_idx,][[date_col]],
"); potential confirmation visits available: no.", paste(conf_idx, collapse = ", "))
}
# Confirmation
# ============
# CONFIRMED IMPROVEMENT:
# --------------------
if (length(conf_idx) > 0 &&
data_id[change_idx, value_col] - bl[[value_col]] <= - delta(bl[[value_col]]) &&
all(sapply((change_idx + 1):conf_idx[[1]], function(x) data_id[x, value_col] - bl[[value_col]]
<= -delta(bl[[value_col]]))) &&
phase == 0) {
if (conf_idx[[1]]==nvisits) {next_change <- NA} else {
next_change <- which(data_id[(conf_idx[[1]] + 1):nvisits, value_col] - bl[[value_col]]
> -delta(bl[[value_col]]))[1] + conf_idx[[1]]
}
if (!is.na(next_change)) {
conf_idx <- conf_idx[conf_idx < next_change]
}
conf_t <- conf_t[seq_along(conf_idx)]
# sustained until:
next_change <- NA
if (conf_idx[[length(conf_idx)]]<nvisits) {
for (x in (conf_idx[[length(conf_idx)]] + 1):nvisits) {
if ((data_id[x,][[value_col]] - bl[[value_col]]) > -delta(bl[[value_col]]) ||
abs(data_id[x,][[value_col]] - data_id[conf_idx[[length(conf_idx)]],][[value_col]])
>= delta(data_id[conf_idx[[length(conf_idx)]],][[value_col]])) {
next_change <- x
break
}
}
next_nonsust <- which(data_id[(conf_idx[[length(conf_idx)]] + 1):nvisits, value_col]
- bl[[value_col]] > -delta(bl[[value_col]]))[1] + conf_idx[[length(conf_idx)]]
} else {next_nonsust <- NA}
valid_impr <- 1
if (require_sust_months) {
valid_impr <- is.na(next_nonsust) || (data_id[next_nonsust, date_col]
- data_id[conf_idx[[length(conf_idx)]], date_col]) > require_sust_months * 30.44
}
if (valid_impr) {
sust_idx <- ifelse(is.na(next_nonsust), nvisits, next_nonsust - 1)
event_type <- c(event_type, "impr")
event_index <- c(event_index, change_idx)
bldate <- c(bldate, as.character(bl[[date_col]]))
blvalue <- c(blvalue, bl[[value_col]])
edate <- c(edate, as.character(data_id[change_idx,][[date_col]]))
evalue <- c(evalue, data_id[change_idx,][[value_col]])
time2event <- c(time2event, difftime(data_id[change_idx,][[date_col]], bl[[date_col]]))
for (m in conf_months) {
conf[[as.character(m)]] <- c(conf[[as.character(m)]], as.integer(m %in% conf_t))
if (m!=conf_months[1]) {pira_conf[[as.character(m)]] <- c(pira_conf[[as.character(m)]], NA)}
}
sustd <- c(sustd, difftime(data_id[sust_idx,][[date_col]], data_id[conf_idx[[length(conf_idx)]],][[date_col]]))
sustl <- c(sustl, as.integer(sust_idx == nvisits))
if (baseline == "roving") {
bl_idx <- ifelse(is.na(next_change), nvisits, next_change - 1)
search_idx <- bl_idx + 1
} else {
search_idx <- ifelse(is.na(next_change), nvisits, next_change)
}
if (verbose == 2) {
message(toupper(outcome), " improvement (visit no.", change_idx, ", ", data_id[change_idx,][[date_col]],
") confirmed at ", paste(conf_t, collapse = ", "), " months, sustained up to visit no.", sust_idx,
" (", data_id[sust_idx,][[date_col]], ")")
message("New settings: baseline at visit no.", bl_idx, ", searching for events from visit no.",
ifelse(search_idx > nvisits, "-", search_idx), " on")
}
} else {
search_idx <- change_idx + 1
if (verbose == 2) {
message("Change confirmed but not sustained for >=", require_sust_months,
" months: proceed with search")
}
}
}
# Confirmed sub-threshold improvement: RE-BASELINE
# ------------------------------------------------
else if (length(conf_idx) > 0 && # confirmation visits available
data_id[change_idx, value_col] < bl[value_col] && # value decreased from baseline
data_id[conf_idx[[1]], value_col] < bl[value_col] && # decrease is confirmed
baseline == 'roving' && sub_threshold &&
phase == 0) { # skip if re-checking for PIRA after post-relapse re-baseline
if (conf_idx[[1]]==nvisits) {
next_change <- NA} else {
next_change <- which(data_id[(conf_idx[[1]] + 1):nvisits, value_col]
> bl[[value_col]])[1] + conf_idx[[1]] }
bl_idx <- ifelse(is.na(next_change), nvisits, next_change - 1) # set new baseline at last consecutive decreased value
search_idx <- next_change
if (verbose == 2) {
message("Confirmed sub-threshold ", toupper(outcome), " improvement (visit no.", change_idx, ")")
message("New settings: baseline at visit no.", bl_idx, ", searching for events from visit no.",
ifelse(is.na(search_idx), "-", search_idx), " on")
}
}
# CONFIRMED PROGRESSION:
# ---------------------
else if (data_id[change_idx, value_col] >= min_value &&
data_id[change_idx, value_col] - bl[value_col] >= delta(bl[value_col]) && # value increased (>delta) from baseline
((length(conf_idx) > 0 && # confirmation visits available
all(sapply((change_idx + 1):conf_idx[[1]],
function(x) data_id[x, value_col] - bl[value_col] >= delta(bl[value_col]))) && # increase is confirmed at first valid date
all(sapply((change_idx + 1):conf_idx[[1]],
function(x) data_id[x, value_col] >= min_value)) # confirmation above min_value too
) || (prog_last_visit && change_idx == nvisits))
) {
if (change_idx == nvisits) {
conf_idx <- c(nvisits)
}
if (conf_idx[[1]]==nvisits) {
next_change <- NA} else {
next_change <- which(data_id[(conf_idx[[1]] + 1):nvisits, value_col] - bl[[value_col]]
< delta(bl[[value_col]]))[1] + conf_idx[[1]] }
if (!is.na(next_change)) {
conf_idx <- conf_idx[conf_idx < next_change] } # confirmed dates
conf_t <- conf_t[seq_along(conf_idx)]
# sustained until:
next_change <- NA
if (conf_idx[[length(conf_idx)]]<nvisits) {
for (x in (conf_idx[[length(conf_idx)]] + 1):nvisits) {
if (data_id[x,][[value_col]] - bl[[value_col]] < delta(bl[[value_col]]) ||
abs(data_id[x,][[value_col]] - data_id[conf_idx[[length(conf_idx)]],][[value_col]])
>= delta(data_id[conf_idx[[length(conf_idx)]],][[value_col]])) {
next_change <- x
break
}
}
next_nonsust <- which(data_id[(conf_idx[[length(conf_idx)]] + 1):nvisits, value_col]
- bl[[value_col]] < delta(bl[[value_col]]))[1] + conf_idx[[length(conf_idx)]]
} else {next_nonsust <- NA}
valid_prog <- 1
if (require_sust_months) {
valid_prog <- is.na(next_nonsust) || difftime(data_id[next_nonsust,][[date_col]],
data_id[conf_idx[[length(conf_idx)]],][[date_col]]) > require_sust_months * 30.44
}
if (valid_prog) {
sust_idx <- ifelse(is.na(next_nonsust), nvisits, next_nonsust - 1)
if (phase == 0 && data_id[change_idx, 'closest_rel_minus'] <= rel_infl) { # event occurs within relapse influence
event_type <- c(event_type, 'RAW')
event_index <- c(event_index, change_idx)
} else if (data_id[change_idx, 'closest_rel_minus'] > rel_infl) { # event occurs out of relapse influence
rel_inbetween <- sapply(conf_idx,
function(ic) any(is_rel[date_dict[[as.character(bl_idx)]]:date_dict[[as.character(ic)]]]))
if (any(rel_inbetween)) {
if (min(which(rel_inbetween))>1) {
pconf_idx <- conf_idx[1:(min(which(rel_inbetween)) - 1)] } else {pconf_idx = list()}
} else {pconf_idx = conf_idx}
if (length(pconf_idx) > 0
&& data_id[pconf_idx[[length(pconf_idx)]], 'closest_rel_plus'] <= rel_infl) {
pconf_idx <- pconf_idx[-length(pconf_idx)]
}
pconf_t <- conf_t[seq_along(pconf_idx)]
if (length(pconf_idx) > 0) {
for (m in conf_months) {
if (m!=conf_months[1]) {
pira_conf[[as.character(m)]] <- c(pira_conf[[as.character(m)]], as.integer(m %in% pconf_t))}
}
event_type <- c(event_type, 'PIRA')
event_index <- c(event_index, change_idx)
} else if (phase == 0) {
event_type <- c(event_type, 'prog')
event_index <- c(event_index, change_idx)
}
}
if (phase==0 & event_type[length(event_type)] != 'PIRA') {
for (m in conf_months) {
if (m!=conf_months[1]) {pira_conf[[as.character(m)]] <- c(pira_conf[[as.character(m)]], NA)}
}
}
if (event_type[length(event_type)] == 'PIRA' || phase == 0) {
bldate <- c(bldate, as.character(bl[[date_col]]))
blvalue <- c(blvalue, bl[[value_col]])
edate <- c(edate, as.character(data_id[change_idx,][[date_col]]))
evalue <- c(evalue, data_id[change_idx,][[value_col]])
time2event <- c(time2event, difftime(data_id[change_idx,][[date_col]], bl[[date_col]]))
for (m in conf_months) {
conf[[as.character(m)]] <- c(conf[[as.character(m)]], as.integer(m %in% conf_t))
}
sustd <- c(sustd, difftime(data_id[sust_idx,][[date_col]],
data_id[conf_idx[[length(conf_idx)]],][[date_col]]))
sustl <- c(sustl, as.integer(sust_idx == nvisits))
if (verbose == 2) {
message(toupper(outcome), " progression[", event_type[length(event_type)],
"] (visit no.", change_idx, ", ", data_id[change_idx,][[date_col]],
") confirmed at ", paste(conf_t, collapse = ", "), " months, sustained up to visit no.", sust_idx,
" (", data_id[sust_idx,][[date_col]], ")")
}
}
if (baseline == 'roving' || (event_type[length(event_type)] == 'PIRA' && phase == 1)) {
bl_idx <- ifelse(is.na(next_change), nvisits, next_change - 1) # set new baseline at last confirmation time
search_idx <- bl_idx + 1
} else {
search_idx <- ifelse(is.na(next_change), nvisits, next_change) # next_nonsust
}
if (verbose == 2 && phase == 0) {
message("New settings: baseline at visit no.", bl_idx, ", searching for events from visit no.",
ifelse(search_idx > nvisits, "-", search_idx), " on")
}
} else {
search_idx <- change_idx + 1 # skip the change and look for other patterns after it
if (verbose == 2) {
message("Change confirmed but not sustained for >=", require_sust_months,
" months: proceed with search")
}
}
}
# Confirmed sub-threshold progression: RE-BASELINE
# ------------------------------------------------
else if (length(conf_idx) > 0 && data_id[change_idx, value_col] > bl[[value_col]]
&& data_id[conf_idx[[1]], value_col] > bl[[value_col]] && baseline == "roving"
&& sub_threshold && phase == 0) {
if (conf_idx[[1]]==nvisits) {
next_change <- NA} else {
next_change <- which(data_id[(conf_idx[[1]] + 1):nvisits, value_col]
< bl[[value_col]])[1] + conf_idx[[1]] }
bl_idx <- ifelse(is.na(next_change), nvisits, next_change - 1)
search_idx <- bl_idx + 1
if (verbose == 2) {
message("Confirmed sub-threshold", toupper(outcome), "progression (visit no.", change_idx, ")")
message("New settings: baseline at visit no.", bl_idx,
", searching for events from visit no.", search_idx, " on")
}
}
# NO confirmation:
# ----------------
else {
search_idx <- change_idx + 1
if (verbose == 2) {
message("Change not confirmed: proceed with search")
}
}
}
if (relapse_rebl && phase == 0 && !proceed) { # && !("PIRA" %in% event_type)
phase <- 1
proceed <- 1
search_idx <- bl_idx + 1
if (verbose == 2) {
message("Completed search with fixed baseline, re-search for PIRA events with post-relapse rebaseline")
}
}
if (proceed && ((event == "first" && length(event_type) > 1) ||
(event == "firsteach" && ("impr" %in% event_type) && ("prog" %in% event_type)) ||
(event == "firstprog" && (("RAW" %in% event_type) || ("PIRA" %in% event_type) || ("prog" %in% event_type))) ||
(event == "firstprogtype" && ("RAW" %in% event_type) && ("PIRA" %in% event_type) && ("prog" %in% event_type)))) {
proceed <- 0
if (verbose == 2) {
message("First events already found: end process")
}
}
if (proceed && search_idx <= nvisits && relapse_rebl && phase == 1) {
if (bl_idx < nvisits) {
bl_idx <- sapply(bl_idx, function (ib) {
out <- NA
for (x in (ib + 1):nvisits) { # visits after current baseline (or after last confirmed PIRA)
if (any(is_rel[date_dict[[as.character(ib)]]:date_dict[[as.character(x)]]]) # after a relapse
& (data_id[x, 'closest_rel_minus'] > rel_infl) # out of relapse influence
){
out <- x
break
}
}
out
})
} else {bl_idx <- NA}
if (!is.na(bl_idx)) {
search_idx <- bl_idx + 1
if (verbose == 2) {
message("New settings: baseline at visit no.", bl_idx,
", searching for events from visit no.", search_idx, " on")
}
}
}
if (proceed && (is.na(bl_idx) || bl_idx > nvisits - 1)) {
proceed <- 0
if (verbose == 2) {
message("Not enough visits after current baseline: end process")
}
}
} #while (proceed)
subj_index <- as.numeric(row.names(results[results[subj_col] == subjid, ]))
if (length(event_type) > 1) {
event_type <- event_type[2:length(event_type)]  # remove first empty event
# Spot duplicate events
# (can only occur if relapse_rebl is enabled - in that case, only keep last detected)
uevents <- unique(event_index)
ucounts <- table(event_index)
duplicates <- uevents[ucounts > 1]
diff <- length(event_index) - length(uevents) # keep track of no. duplicates
for (ev in duplicates) {
all_ind <- which(event_index == ev)
event_index[all_ind[-length(all_ind)]] <- 0 # mark duplicate events with 0
}
event_order <- order(event_index)
event_order <- event_order[(diff+1):length(event_order)] # eliminate duplicates (those marked with 0)
event_type <- event_type[event_order]
if (startsWith(event, "first")) {
impr_idx <- which(event_type == "impr")[1]
prog_idx <- which(event_type %in% c("prog", "RAW", "PIRA"))[1]
raw_idx <- which(event_type == "RAW")[1]
pira_idx <- which(event_type == "PIRA")[1]
undef_prog_idx <- which(event_type == "prog")[1]
if (event == "firsteach") {
first_events <- c(impr_idx, prog_idx)
} else if (event == "firstprog") {
first_events <- c(prog_idx)
} else if (event == "firstprogtype") {
first_events <- c(raw_idx, pira_idx, undef_prog_idx)
}
if (event=='first') {first_events <- 1} else {first_events <- unique(na.omit(first_events))}
event_type <- event_type[first_events]
event_order <- event_order[first_events]
}
results <- results[-subj_index[(length(event_type) + 1):length(subj_index)], ]
rownames(results) <- NULL # reset column names
results[results[[subj_col]] == subjid, "event_type"] <- event_type
results[results[[subj_col]] == subjid, "bldate"] <- bldate[event_order]
results[results[[subj_col]] == subjid, "blvalue"] <- blvalue[event_order]
results[results[[subj_col]] == subjid, "date"] <- edate[event_order]
results[results[[subj_col]] == subjid, "value"] <- evalue[event_order]
results[results[[subj_col]] == subjid, "time2event"] <- time2event[event_order]
for (m in conf_months) {
results[results[[subj_col]] == subjid, paste0("conf", m)] <- conf[[as.character(m)]][event_order]
}
results[results[[subj_col]] == subjid, "sust_days"] <- sustd[event_order]
results[results[[subj_col]] == subjid, "sust_last"] <- sustl[event_order]
for (m in conf_months) {
if (m!=conf_months[1]) {
results[results[[subj_col]] == subjid, paste0("PIRA_conf", m)] <- pira_conf[[as.character(m)]][event_order]}
}
} else {
results <- results[-subj_index, ]
rownames(results) <- NULL # reset column names
}
improvement <- sum(results[results[[subj_col]] == subjid, "event_type"] == "impr")
progression <- sum(results[results[[subj_col]] == subjid, "event_type"] %in% c("prog", "RAW", "PIRA"))
undefined_prog <- sum(results[results[[subj_col]] == subjid, "event_type"] == "prog")
RAW <- sum(results[results[[subj_col]] == subjid, "event_type"] == "RAW")
PIRA <- sum(results[results[[subj_col]] == subjid, "event_type"] == "PIRA")
summary[as.character(subjid), c('improvement', 'progression', 'RAW', 'PIRA', 'undefined_prog'
)] <- c(improvement, progression, RAW, PIRA, undefined_prog)
summary[as.character(subjid), 'event_sequence'] <- paste(event_type, collapse = ", ")
if (startsWith(event, "firstprog")) {
summary <- summary[, !colnames(summary) %in% "improvement"]
}
if (verbose == 2) {
message("Event sequence: ", ifelse(length(event_type) > 0,
paste(event_type, collapse = ", "), "-"), sep = "")
}
msprog::MSprog
msprog::MSprog(data, subj_col, value_col, date_col)
library(msprog)
usethis::use_readme_rmd()
R version
R. Version()
R.Version()
View(bl)
vignette(package='msprog')
library(msprog)
vignette(package='msprog')
browseVignettes(msprog)
browseVignettes('msprog')
library(msprog)
browseVignettes('msprog')
vignettes(package='msprog')
devtools::install(build_vignettes = TRUE)
devtools::install('msprog', build_vignettes = TRUE)
devtools::install(build_vignettes = TRUE)
library(msprog)
vignettes(package='msprog')
browseVignettes('msprog')
browseVignettes('msprog')
devtools::install_github("noemimontobbio/msprog", build_vignettes = TRUE)
browseVignettes('msprog')
library(msprog)
help("MSprog")
??msprog
??msprog
devtools::install_github("noemimontobbio/msprog", build_vignettes = TRUE)
library(msprog)
??msprog
install.packages("badger")
library(badger)
